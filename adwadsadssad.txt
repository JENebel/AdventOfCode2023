procedure Part2;
var
    inputFile: TextFile;
    line: string;
    numstr: string;
    delimiterPos: integer;
    i, j, k: Int64;
    rawSeeds: array[1..MaxRawSeeds] of Int64;
    seeds: array of Int64;
    seedCnt: integer;
    rawSeedCnt: integer;

    intervals: array[1..Phases] of array[1..MaxIntervals] of Int64;
    intervalCounts: array[1..Phases] of integer;

    temp: Int64;
    destination: Int64;
    source: Int64;
    len: Int64;
    offset: Int64;
    min: Int64;

    code: Integer;
begin
    Assign(inputFile, '../inputs/dec5.input');
    Reset(inputFile);

    Readln(inputFile, line);
    line := Copy(line, 8, Length(Line));

    rawSeedCnt := 1;

    j := 1;
    while Pos(' ', line) > 0 do begin
        delimiterPos := Pos(' ', line);
        numstr := Copy(line, 1, delimiterPos - 1);
        Inc(rawSeedCnt);
        line := Copy(line, delimiterPos + 1, Length(Line));
        Val(numstr, i, code);
        rawSeeds[j] := i;
        Inc(j);
    end;
    // Get last seed
    Val(line, i, code);
    rawSeeds[j] := i;
    
    // Expand seed ranges
    SetLength(seeds, 1246535471);
    seedCnt := 1; // Init to 1 for indexing
    for k := 1 to Round(rawSeedCnt / 2) do begin
        j := k * 2; // Actual index
        for i := 0 to rawSeeds[j+1]-1 do begin
            seeds[seedCnt] := rawSeeds[j] + i;
        end;
    end;
    Dec(seedCnt); // decrement to avoid off by one

    // Add intervals
    Readln(inputFile, line);
    for j := 1 to Phases do begin
        intervalCounts[i] := 0;
        Readln(inputFile, line);
        k := 1;
        while true do begin
            Readln(inputFile, line);
            if line = '' then break;
            delimiterPos := Pos(' ', line);
            numstr := Copy(line, 1, delimiterPos - 1);
            Inc(intervalCounts[j]);
            line := Copy(line, delimiterPos + 1, Length(Line));
            Val(numstr, i, code);
            intervals[j][k] := i;
            Inc(k);

            delimiterPos := Pos(' ', line);
            numstr := Copy(line, 1, delimiterPos - 1);
            Inc(intervalCounts[j]);
            line := Copy(line, delimiterPos + 1, Length(Line));
            Val(numstr, i, code);
            intervals[j][k] := i;
            Inc(k);

            Inc(intervalCounts[j]);
            Val(line, i, code);
            intervals[j][k] := i;
            Inc(k);
        end;
    end;

    // Calculate min
    destination := 0;
    source := 0;
    len := 0;
    offset := 0;
    min := MaxInt;
    for k := 1 to seedCnt do begin
        temp := seeds[k];
        for i := 1 to 7 do begin
            for j := 1 to intervalCounts[i] do begin
                destination := intervals[i][j];
                source := intervals[i][j+1];
                len := intervals[i][j+2];
                offset := destination - source;
                
                if ((temp > source) and (temp < source + len)) then begin
                    temp := temp + offset;
                    break;
                end;

                // Hack to step by 3
                inc(PInteger(@j)^);
                inc(PInteger(@j)^);
            end;
        end;
        writeln(temp);
        if temp < min then
            min := temp;
    end;

    writeln('Part 2: ', min);
end;

begin
    Part1;
    //Part2;
end.
